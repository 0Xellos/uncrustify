#
# The type of line endings
newlines                        = lf

indent_with_tabs                = 0
input_tab_size                  = 8
output_tab_size                 = 1
indent_columns                  = 4
indent_label                    = 2
indent_align_string             = False
indent_brace                    = 0
# Spaces to indent 'case' from 'switch'
# Usually 0 or indent_columns.
indent_switch_case              = indent_columns


nl_enum_brace                   = force
nl_union_brace                  = force
nl_struct_brace                 = force
nl_do_brace                     = force
nl_if_brace                     = force
nl_for_brace                    = force
nl_else_brace                   = force
nl_while_brace                  = force
nl_switch_brace                 = force
# nl_before_case                        = 1
nl_fcall_brace                  = force
nl_fdef_brace                   = force
nl_after_return                 = TRUE
nl_brace_while                  = force
nl_brace_else                   = force
nl_squeeze_ifdef                = TRUE
# Whether to put a newline after 'case' statement
nl_after_case                   = true

# Add or remove newline after each ',' in a function declaration
nl_func_decl_args               = ignore

# Add or remove newline after each ',' in a function definition
nl_func_def_args                = force

# Add or remove newline after '(' in a function declaration
nl_func_decl_start              = ignore

# Add or remove newline after '(' in a function definition
nl_func_def_start               = force

# The number of newlines after '}' of a multi-line function body
nl_after_func_body              = 3

# The number of newlines after '}' of a single line function body
nl_after_func_body_one_liner    = 3

# The number of blank lines after a block of variable definitions
nl_func_var_def_blk             = 1

# The number of newlines after a function prototype, if followed by another function prototype
nl_after_func_proto             = 1

# The number of newlines after a function prototype, if not followed by another function prototype
nl_after_func_proto_group       = 2

# The maximum consecutive newlines
nl_max                          = 2

# Whether to put a newline after semicolons, except in 'for' statements
nl_after_semicolon              = true

# Whether to force a newline after a multi-line comment.
nl_after_multiline_comment      = true

# Whether to put a newline after brace open.
# This also adds a newline before the matching brace close.
nl_after_brace_open             = true

# If nl_after_brace_open and nl_after_brace_open_cmt are true, a newline is
# placed between the open brace and a trailing single-line comment.
nl_after_brace_open_cmt         = true

# Whether to put a newline after a brace close.
# Does not apply if followed by a necessary ';'.
nl_after_brace_close            = true

# The minimum number of newlines before a multi-line comment.
# Doesn't apply if after a brace open or another multi-line comment.
nl_before_block_comment         = 0

# The minimum number of newlines before a single-line C comment.
# Doesn't apply if after a brace open or other single-line C comments.
nl_before_c_comment             = 0

# The minimum number of newlines before a CPP comment.
# Doesn't apply if after a brace open or other CPP comments.
nl_before_cpp_comment           = 0

# Whether to force a newline after a multi-line comment.
nl_after_multiline_comment      = false

# The minimum number of newlines after a single-line C comment.
# Doesn't apply if after a brace open or other single-line C comments.
# I'm not sure if this is actually an option, but it should be;  gad
#nl_after_c_comment                      = 2        # number

# The minimum number of newlines after a multi-line comment.
# Doesn't apply if after a brace open or another multi-line comment.
# I'm not sure if this is actually an option, but it should be;  gad
#nl_after_block_comment                  = 2        # number











# mod_paren_on_return           = add           # "return 1;" vs "return (1);"
mod_full_brace_if               = add
mod_full_brace_for              = add
mod_full_brace_do               = add
mod_full_brace_while            = add

sp_before_semi                  = remove
sp_paren_paren                  = force
sp_return_paren                 = force
sp_sizeof_paren                 = remove
sp_before_sparen                = force
sp_after_sparen                 = force
sp_after_cast                   = force
sp_inside_braces                = force
sp_inside_braces_struct         = force
sp_inside_braces_enum           = force
sp_inside_paren                 = force
sp_inside_fparen                = force
sp_inside_sparen                = force
#sp_type_func                   = ignore
sp_assign                       = force
sp_arith                        = force
sp_bool                         = force
sp_compare                      = force
sp_assign                       = force
sp_after_comma                  = force
sp_func_def_paren               = force
sp_func_call_paren              = force
sp_func_proto_paren             = force
# Add or remove space between type and word. Default=Force
sp_after_type                   = force



# Add or remove space before pointer star '*'
sp_before_ptr_star              = force


# Add or remove space between pointer stars '*'
sp_between_ptr_star             = remove

# Add or remove space after pointer star '*', if followed by a word.
sp_after_ptr_star               = remove

# Add or remove space after a pointer star '*', if followed by a func proto/def.
sp_after_ptr_star_func          = ignore

# Add or remove space before a pointer star '*', if followed by a func proto/def.
sp_before_ptr_star_func         = ignore

# Add or remove space before pointer star '*' that isn't followed by a variable name
# If set to 'ignore', sp_before_ptr_star is used instead.
sp_before_unnamed_ptr_star      = remove





# Add or remove space before a reference sign '&'
sp_before_byref                 = force

# Add or remove space before a reference sign '&' that isn't followed by a variable name
# If set to 'ignore', sp_before_byref is used instead.
sp_before_unnamed_byref         = ignore

# Add or remove space after reference sign '&', if followed by a word.
sp_after_byref                  = remove

# Add or remove space after a reference sign '&', if followed by a func proto/def.
sp_after_byref_func             = ignore

# Add or remove space before a reference sign '&', if followed by a func proto/def.
sp_before_byref_func            = ignore

# Add or remove space between the operator symbol and the open paren, as in 'operator ++('
sp_after_operator_sym           = remove







align_with_tabs                 = FALSE
align_on_tabstop                = FALSE
align_enum_equ_span             = 4
align_nl_cont                   = TRUE
align_var_def_span              = 2
align_var_def_inline            = TRUE
# How to align the star in variable definitions.
#  0=Part of the type     'void *   foo;'
#  1=Part of the variable 'void     *foo;'
#  2=Dangling             'void    *foo;'
align_var_def_star_style        = 0

# How to align the star in variable definitions.
#  0=Part of the type     'void *   foo;'
#  1=Part of the variable 'void     *foo;'
#  2=Dangling             'void    *foo;'
align_var_def_star_style        = 1

# How to align the '&' in variable definitions.
#  0=Part of the type
#  1=Part of the variable
#  2=Dangling
align_var_def_amp_style         = 1



align_var_def_colon             = TRUE
align_assign_span               = 100000
# The threshold for aligning on '=' in assignments (0=no limit)
align_assign_thresh             = 0

align_struct_init_span          = 3
align_var_struct_span           = 3
align_right_cmt_span            = 15
# If a trailing comment is more than this number of columns away from the text it follows,
# it will qualify for being aligned. This has to be > 0 to do anything.
align_right_cmt_gap             = 1

align_pp_define_span            = 3
align_pp_define_gap             = 4
align_number_right              = TRUE
align_typedef_span              = 5
align_typedef_gap               = 3
align_func_params               = true
# Align parameters in single-line functions that have the same name.
# The function names must already be aligned with each other.
align_same_func_call_params     = true

# The span for aligning function prototypes (0=don't align)
align_func_proto_span           = 100

# Minimum gap between the return type and the function name.
align_func_proto_gap            = 5

# Align function protos on the 'operator' keyword instead of what follows
align_on_operator               = true

# Whether to mix aligning prototype and variable declarations.
# If true, align_var_def_XXX options are used instead of align_func_proto_XXX options.
align_mix_var_proto             = false

# The gap for aligning struct/union member definitions
align_var_struct_gap            = 14



# cmt_star_cont                 = TRUE

eat_blanks_before_close_brace   = TRUE
eat_blanks_after_open_brace     = TRUE




# Try to limit code width to N number of columns
code_width                      = 0

# Try to wrap comments at cmt_width columns
cmt_width                       = 0


# Set the comment reflow mode (default: 0)
# 0: no reflowing (apart from the line wrapping due to cmt_width)
# 1: no touching at all
# 2: full reflow
cmt_reflow_mode                 = 0


# If false, disable all multi-line comment changes, including cmt_width. keyword substitution, and leading chars.
# Default is true.
cmt_indent_multi                = false

# Whether to group c-comments that look like they are in a block
cmt_c_group                     = false

# Whether to put an empty '/*' on the first line of the combined c-comment
cmt_c_nl_start                  = true

# Whether to put a newline before the closing '*/' of the combined c-comment
cmt_c_nl_end                    = true

# Whether to indent comments found in first column
indent_col1_comment             = false


#
# Positioning options
#

# The position of arithmetic operators in wrapped expressions
pos_arith                       = trail

# The position of assignment in wrapped expressions.
# Do not affect '=' followed by '{'
pos_assign                      = trail

# The position of boolean operators in wrapped expressions
pos_bool                        = trail

# The position of comparison operators in wrapped expressions
pos_compare                     = trail

# The position of conditional (b ? t : f) operators in wrapped expressions
pos_conditional                 = trail

# The position of the comma in wrapped expressions
pos_comma                       = trail

# The position of the comma in the constructor initialization list
pos_class_comma                 = trail

# The position of colons between constructor and member initialization
pos_class_colon                 = trail
